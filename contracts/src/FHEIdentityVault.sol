// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";
import {externalEuint64} from "encrypted-types/EncryptedTypes.sol";

/**
 * @title FHEIdentityVault
 * @notice Simplified FHE-based identity management contract
 * @dev Only encrypts netWorth (euint64), other fields are plaintext
 *      Migrated to fhEVM 0.9.1 with ZamaEthereumConfig
 *
 * Key improvements over previous version:
 * 1. Proper client-side encryption with einput + inputProof pattern
 * 2. Single encrypted field (netWorth) to optimize gas costs
 * 3. No complex architecture - straightforward implementation
 * 4. Reliable on-chain storage and access control
 */
contract FHEIdentityVault is ZamaEthereumConfig {
    // ═══════════════════════════════════════════════════════════════
    // DATA STRUCTURES
    // ═══════════════════════════════════════════════════════════════

    struct Identity {
        address owner;                    // Identity owner
        euint64 encryptedNetWorth;        // ⭐ ONLY encrypted field
        uint32 domicile;                  // Domicile score (0-100) - plaintext
        uint16 tier;                      // Tier level (0-10) - plaintext
        uint8 pep;                        // PEP status (0-1) - plaintext
        uint8 watchlist;                  // Watchlist score (0-5) - plaintext
        uint8 riskScore;                  // Risk score (0-100) - plaintext
        uint64 createdAt;                 // Creation timestamp
        uint64 updatedAt;                 // Last update timestamp
        bool exists;                      // Existence flag
    }

    // ═══════════════════════════════════════════════════════════════
    // STATE VARIABLES
    // ═══════════════════════════════════════════════════════════════

    // Identity storage: address => Identity
    mapping(address => Identity) public identities;

    // Track total number of identities
    uint256 public totalIdentities;

    // ═══════════════════════════════════════════════════════════════
    // EVENTS
    // ═══════════════════════════════════════════════════════════════

    event IdentityCreated(
        address indexed owner,
        uint32 domicile,
        uint16 tier,
        uint64 timestamp
    );

    event IdentityUpdated(
        address indexed owner,
        uint64 timestamp
    );

    // ═══════════════════════════════════════════════════════════════
    // ERRORS
    // ═══════════════════════════════════════════════════════════════

    error IdentityAlreadyExists();
    error IdentityNotFound();
    error Unauthorized();
    error InvalidInput();

    // ═══════════════════════════════════════════════════════════════
    // CORE FUNCTIONS
    // ═══════════════════════════════════════════════════════════════

    /**
     * @notice Create new identity with encrypted netWorth
     * @dev Uses fhEVM 0.9.1 pattern: externalEuint64 + inputProof from SDK
     *
     * @param encryptedNetWorth - Encrypted netWorth from client-side SDK
     * @param inputProof - Input proof generated by SDK to verify encryption
     * @param domicile - Domicile score (0-100)
     * @param tier - Tier level (0-10)
     * @param pep - PEP status (0 or 1)
     * @param watchlist - Watchlist score (0-5)
     * @param riskScore - Risk score (0-100)
     */
    function createIdentity(
        externalEuint64 encryptedNetWorth,
        bytes calldata inputProof,
        uint32 domicile,
        uint16 tier,
        uint8 pep,
        uint8 watchlist,
        uint8 riskScore
    ) external {
        // Check if identity already exists
        if (identities[msg.sender].exists) revert IdentityAlreadyExists();

        // Validate plaintext inputs
        if (domicile > 100) revert InvalidInput();
        if (tier > 10) revert InvalidInput();
        if (pep > 1) revert InvalidInput();
        if (watchlist > 5) revert InvalidInput();
        if (riskScore > 100) revert InvalidInput();

        // ✅ Convert external encrypted input to euint64 with proof verification (fhEVM 0.9.1 API)
        euint64 netWorth = FHE.fromExternal(encryptedNetWorth, inputProof);

        // Store identity
        identities[msg.sender] = Identity({
            owner: msg.sender,
            encryptedNetWorth: netWorth,
            domicile: domicile,
            tier: tier,
            pep: pep,
            watchlist: watchlist,
            riskScore: riskScore,
            createdAt: uint64(block.timestamp),
            updatedAt: uint64(block.timestamp),
            exists: true
        });

        // Allow owner to reencrypt their own netWorth for reading
        FHE.allow(netWorth, msg.sender);

        // Allow contract to use this value in computations
        FHE.allowThis(netWorth);

        totalIdentities++;

        emit IdentityCreated(msg.sender, domicile, tier, uint64(block.timestamp));
    }

    /**
     * @notice Update identity data (can update encrypted netWorth)
     * @dev Uses fhEVM 0.9.1 pattern: externalEuint64 + inputProof from SDK
     * @param encryptedNetWorth - New encrypted netWorth
     * @param inputProof - Input proof for new netWorth
     * @param domicile - New domicile score
     * @param tier - New tier level
     * @param pep - New PEP status
     * @param watchlist - New watchlist score
     * @param riskScore - New risk score
     */
    function updateIdentity(
        externalEuint64 encryptedNetWorth,
        bytes calldata inputProof,
        uint32 domicile,
        uint16 tier,
        uint8 pep,
        uint8 watchlist,
        uint8 riskScore
    ) external {
        Identity storage identity = identities[msg.sender];
        if (!identity.exists) revert IdentityNotFound();

        // Validate plaintext inputs
        if (domicile > 100) revert InvalidInput();
        if (tier > 10) revert InvalidInput();
        if (pep > 1) revert InvalidInput();
        if (watchlist > 5) revert InvalidInput();
        if (riskScore > 100) revert InvalidInput();

        // Update encrypted netWorth (fhEVM 0.9.1 API)
        euint64 newNetWorth = FHE.fromExternal(encryptedNetWorth, inputProof);
        identity.encryptedNetWorth = newNetWorth;

        // Allow owner to read new value
        FHE.allow(newNetWorth, msg.sender);
        FHE.allowThis(newNetWorth);

        // Update plaintext fields
        identity.domicile = domicile;
        identity.tier = tier;
        identity.pep = pep;
        identity.watchlist = watchlist;
        identity.riskScore = riskScore;
        identity.updatedAt = uint64(block.timestamp);

        emit IdentityUpdated(msg.sender, uint64(block.timestamp));
    }

    // ═══════════════════════════════════════════════════════════════
    // VIEW FUNCTIONS
    // ═══════════════════════════════════════════════════════════════

    /**
     * @notice Check if address has identity
     */
    function hasIdentity(address user) external view returns (bool) {
        return identities[user].exists;
    }

    /**
     * @notice Get plaintext identity data (excluding encrypted netWorth)
     */
    function getPlaintextData(address user) external view returns (
        uint32 domicile,
        uint16 tier,
        uint8 pep,
        uint8 watchlist,
        uint8 riskScore,
        uint64 createdAt,
        uint64 updatedAt
    ) {
        Identity storage identity = identities[user];
        if (!identity.exists) revert IdentityNotFound();

        return (
            identity.domicile,
            identity.tier,
            identity.pep,
            identity.watchlist,
            identity.riskScore,
            identity.createdAt,
            identity.updatedAt
        );
    }

    /**
     * @notice Get encrypted netWorth handle for reencryption
     * @dev Only owner can call this to get their encrypted data
     * @return Encrypted handle that can be decrypted client-side
     */
    function getEncryptedNetWorth() external view returns (euint64) {
        Identity storage identity = identities[msg.sender];
        if (!identity.exists) revert IdentityNotFound();

        return identity.encryptedNetWorth;
    }

    /**
     * @notice Calculate access level based on identity data
     * @dev Demonstrates FHE computation on encrypted netWorth
     * @return accessLevel - 0=denied, 1=basic, 2=full, 3=premium (encrypted)
     */
    function calculateAccessLevel() external returns (euint8) {
        Identity storage identity = identities[msg.sender];
        if (!identity.exists) revert IdentityNotFound();

        // Thresholds (using smaller units to fit in uint64)
        // Note: uint64 max is ~18.4 ETH, so we use smaller denomination
        uint64 PREMIUM_THRESHOLD = 1_000_000;  // Arbitrary units
        uint64 FULL_THRESHOLD = 100_000;       // Arbitrary units
        uint64 BASIC_THRESHOLD = 10_000;       // Arbitrary units

        // ⭐ FHE comparisons on encrypted netWorth
        ebool isPremium = FHE.ge(identity.encryptedNetWorth, FHE.asEuint64(PREMIUM_THRESHOLD));
        ebool isFull = FHE.ge(identity.encryptedNetWorth, FHE.asEuint64(FULL_THRESHOLD));
        ebool isBasic = FHE.ge(identity.encryptedNetWorth, FHE.asEuint64(BASIC_THRESHOLD));

        // Additional plaintext criteria
        bool plaintextOk = identity.tier >= 5 &&
                         identity.pep == 0 &&
                         identity.watchlist == 0 &&
                         identity.riskScore <= 30;

        // Combine encrypted and plaintext conditions
        ebool finalPremium = FHE.and(isPremium, FHE.asEbool(plaintextOk));
        ebool finalFull = FHE.and(isFull, FHE.asEbool(plaintextOk));
        ebool finalBasic = FHE.and(isBasic, FHE.asEbool(plaintextOk));

        // Return encrypted access level: 3=premium, 2=full, 1=basic, 0=denied
        euint8 accessLevel = FHE.select(
            finalPremium,
            FHE.asEuint8(3),
            FHE.select(
                finalFull,
                FHE.asEuint8(2),
                FHE.select(finalBasic, FHE.asEuint8(1), FHE.asEuint8(0))
            )
        );

        return accessLevel;
    }
}
